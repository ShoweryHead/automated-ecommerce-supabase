const express = require('express');
const router = express.Router();
const { check, validationResult } = require('express-validator');
const BlogAutomationService = require('../services/BlogAutomationService');
const BlogPost = require('../models/BlogPost');
const BlogTopic = require('../models/BlogTopic');
const BlogAutomationSettings = require('../models/BlogAutomationSettings');

// Middleware to validate request
const validate = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ success: false, errors: errors.array() });
  }
  next();
};

/**
 * @route   GET /api/blog/settings
 * @desc    Get blog automation settings
 * @access  Private
 */
router.get('/settings', async (req, res) => {
  try {
    const settings = await BlogAutomationService.getSettings();
    res.json({ success: true, settings });
  } catch (error) {
    console.error('Error getting blog settings:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   PUT /api/blog/settings
 * @desc    Update blog automation settings
 * @access  Private
 */
router.put('/settings', [
  check('contentTypes').optional().isObject(),
  check('publishingSchedule').optional().isObject(),
  check('reviewWorkflow').optional().isObject(),
  check('seoSettings').optional().isObject(),
  check('emailPromotion').optional().isObject(),
  check('contentGenerationAPI').optional().isObject(),
  check('imageGeneration').optional().isObject(),
  check('topicGeneration').optional().isObject(),
  validate
], async (req, res) => {
  try {
    // Get current settings
    let settings = await BlogAutomationSettings.findOne().sort({ createdAt: -1 });
    
    if (!settings) {
      settings = new BlogAutomationSettings();
    }
    
    // Update settings with request body
    Object.keys(req.body).forEach(key => {
      if (key !== '_id' && key !== 'createdAt' && key !== 'updatedAt') {
        settings[key] = req.body[key];
      }
    });
    
    // Set last updated by
    settings.lastUpdatedBy = req.user ? req.user.id : null;
    
    await settings.save();
    
    res.json({ success: true, settings });
  } catch (error) {
    console.error('Error updating blog settings:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   GET /api/blog/topics
 * @desc    Get blog topics
 * @access  Private
 */
router.get('/topics', async (req, res) => {
  try {
    const { status, contentType, limit = 20, page = 1 } = req.query;
    
    // Build query
    const query = {};
    
    if (status) {
      query.status = status;
    }
    
    if (contentType) {
      query.contentType = contentType;
    }
    
    // Calculate pagination
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    // Get topics
    const topics = await BlogTopic.find(query)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit))
      .populate('relatedProducts')
      .populate('relatedCategories')
      .populate('assignedTo', 'name email')
      .populate('blogPost');
    
    // Get total count
    const total = await BlogTopic.countDocuments(query);
    
    res.json({
      success: true,
      topics,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(total / parseInt(limit))
      }
    });
  } catch (error) {
    console.error('Error getting blog topics:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   POST /api/blog/topics/generate
 * @desc    Generate blog topic suggestions
 * @access  Private
 */
router.post('/topics/generate', [
  check('count').optional().isInt({ min: 1, max: 20 }),
  check('contentTypes').optional().isArray(),
  validate
], async (req, res) => {
  try {
    const result = await BlogAutomationService.generateTopicSuggestions(req.body);
    res.json(result);
  } catch (error) {
    console.error('Error generating blog topics:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   POST /api/blog/topics
 * @desc    Create a new blog topic manually
 * @access  Private
 */
router.post('/topics', [
  check('title').notEmpty().withMessage('Title is required'),
  check('description').notEmpty().withMessage('Description is required'),
  check('contentType').isIn(['product', 'industry_news', 'how_to', 'case_study']).withMessage('Valid content type is required'),
  check('primaryKeyword').notEmpty().withMessage('Primary keyword is required'),
  validate
], async (req, res) => {
  try {
    const topic = new BlogTopic({
      ...req.body,
      automation: {
        isAutoGenerated: false,
        generationMethod: 'manual',
        generationDate: new Date()
      }
    });
    
    await topic.save();
    
    res.json({ success: true, topic });
  } catch (error) {
    console.error('Error creating blog topic:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   PUT /api/blog/topics/:id
 * @desc    Update a blog topic
 * @access  Private
 */
router.put('/topics/:id', [
  check('title').optional().notEmpty().withMessage('Title cannot be empty'),
  check('description').optional().notEmpty().withMessage('Description cannot be empty'),
  check('contentType').optional().isIn(['product', 'industry_news', 'how_to', 'case_study']).withMessage('Valid content type is required'),
  check('primaryKeyword').optional().notEmpty().withMessage('Primary keyword cannot be empty'),
  check('status').optional().isIn(['suggested', 'approved', 'rejected', 'in_progress', 'completed']).withMessage('Valid status is required'),
  validate
], async (req, res) => {
  try {
    const topic = await BlogTopic.findById(req.params.id);
    
    if (!topic) {
      return res.status(404).json({ success: false, message: 'Topic not found' });
    }
    
    // Update fields
    Object.keys(req.body).forEach(key => {
      if (key !== '_id' && key !== 'createdAt' && key !== 'updatedAt') {
        if (key === 'automation') {
          // Merge automation object
          topic.automation = { ...topic.automation, ...req.body.automation };
        } else {
          topic[key] = req.body[key];
        }
      }
    });
    
    await topic.save();
    
    res.json({ success: true, topic });
  } catch (error) {
    console.error(`Error updating blog topic ${req.params.id}:`, error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   DELETE /api/blog/topics/:id
 * @desc    Delete a blog topic
 * @access  Private
 */
router.delete('/topics/:id', async (req, res) => {
  try {
    const topic = await BlogTopic.findById(req.params.id);
    
    if (!topic) {
      return res.status(404).json({ success: false, message: 'Topic not found' });
    }
    
    await topic.remove();
    
    res.json({ success: true, message: 'Topic deleted successfully' });
  } catch (error) {
    console.error(`Error deleting blog topic ${req.params.id}:`, error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   POST /api/blog/topics/:id/generate
 * @desc    Generate a blog post draft from a topic
 * @access  Private
 */
router.post('/topics/:id/generate', async (req, res) => {
  try {
    const result = await BlogAutomationService.generateBlogPostDraft(req.params.id);
    res.json(result);
  } catch (error) {
    console.error(`Error generating blog post from topic ${req.params.id}:`, error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   GET /api/blog/posts
 * @desc    Get blog posts
 * @access  Private
 */
router.get('/posts', async (req, res) => {
  try {
    const { status, contentType, limit = 20, page = 1 } = req.query;
    
    // Build query
    const query = {};
    
    if (status) {
      query.status = status;
    }
    
    if (contentType) {
      query.contentType = contentType;
    }
    
    // Calculate pagination
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    // Get posts
    const posts = await BlogPost.find(query)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit))
      .populate('categories')
      .populate('relatedProducts')
      .populate('author', 'name email');
    
    // Get total count
    const total = await BlogPost.countDocuments(query);
    
    res.json({
      success: true,
      posts,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(total / parseInt(limit))
      }
    });
  } catch (error) {
    console.error('Error getting blog posts:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   GET /api/blog/posts/:id
 * @desc    Get a blog post by ID
 * @access  Private
 */
router.get('/posts/:id', async (req, res) => {
  try {
    const post = await BlogPost.findById(req.params.id)
      .populate('categories')
      .populate('relatedProducts')
      .populate('author', 'name email')
      .populate('automation.reviewedBy', 'name email');
    
    if (!post) {
      return res.status(404).json({ success: false, message: 'Blog post not found' });
    }
    
    res.json({ success: true, post });
  } catch (error) {
    console.error(`Error getting blog post ${req.params.id}:`, error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   PUT /api/blog/posts/:id
 * @desc    Update a blog post
 * @access  Private
 */
router.put('/posts/:id', [
  check('title').optional().notEmpty().withMessage('Title cannot be empty'),
  check('content').optional().notEmpty().withMessage('Content cannot be empty'),
  check('status').optional().isIn(['draft', 'review', 'scheduled', 'published', 'archived']).withMessage('Valid status is required'),
  validate
], async (req, res) => {
  try {
    const post = await BlogPost.findById(req.params.id);
    
    if (!post) {
      return res.status(404).json({ success: false, message: 'Blog post not found' });
    }
    
    // If content is being updated, add current content to revisions
    if (req.body.content && req.body.content !== post.content) {
      post.revisions.push({
        content: post.content,
        updatedBy: req.user ? req.user.id : null,
        updatedAt: new Date(),
        changeNotes: req.body.changeNotes || 'Content updated'
      });
    }
    
    // Update fields
    Object.keys(req.body).forEach(key => {
      if (key !== '_id' && key !== 'createdAt' && key !== 'updatedAt' && key !== 'revisions') {
        if (key === 'automation' || key === 'seo') {
          // Merge nested objects
          post[key] = { ...post[key], ...req.body[key] };
        } else {
          post[key] = req.body[key];
        }
      }
    });
    
    await post.save();
    
    res.json({ success: true, post });
  } catch (error) {
    console.error(`Error updating blog post ${req.params.id}:`, error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   POST /api/blog/posts/:id/review
 * @desc    Review a blog post
 * @access  Private
 */
router.post('/posts/:id/review', [
  check('status').isIn(['approved', 'rejected']).withMessage('Valid review status is required'),
  validate
], async (req, res) => {
  try {
    const result = await BlogAutomationService.reviewBlogPost(req.params.id, {
      ...req.body,
      reviewedBy: req.user ? req.user.id : null
    });
    
    res.json(result);
  } catch (error) {
    console.error(`Error reviewing blog post ${req.params.id}:`, error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   POST /api/blog/posts/:id/images
 * @desc    Generate images for a blog post
 * @access  Private
 */
router.post('/posts/:id/images', async (req, res) => {
  try {
    const result = await BlogAutomationService.generateBlogImages(req.params.id);
    res.json(result);
  } catch (error) {
    console.error(`Error generating images for blog post ${req.params.id}:`, error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   POST /api/blog/publish-scheduled
 * @desc    Publish scheduled blog posts
 * @access  Private
 */
router.post('/publish-scheduled', async (req, res) => {
  try {
    const result = await BlogAutomationService.publishScheduledPosts();
    res.json(result);
  } catch (error) {
    console.error('Error publishing scheduled posts:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   POST /api/blog/promote-via-email
 * @desc    Promote blog posts via email
 * @access  Private
 */
router.post('/promote-via-email', async (req, res) => {
  try {
    const result = await BlogAutomationService.promoteBlogPostsViaEmail();
    res.json(result);
  } catch (error) {
    console.error('Error promoting blog posts via email:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

/**
 * @route   GET /api/blog/content-calendar
 * @desc    Generate a content calendar
 * @access  Private
 */
router.get('/content-calendar', async (req, res) => {
  try {
    const { weeks, startDate } = req.query;
    
    const options = {};
    
    if (weeks) {
      options.weeks = parseInt(weeks);
    }
    
    if (startDate) {
      options.startDate = new Date(startDate);
    }
    
    const result = await BlogAutomationService.generateContentCalendar(options);
    res.json(result);
  } catch (error) {
    console.error('Error generating content calendar:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

module.exports = router;
