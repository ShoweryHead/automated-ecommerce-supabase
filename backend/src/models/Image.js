const mongoose = require('mongoose');

const ImageSchema = new mongoose.Schema({
  // Basic information
  filename: {
    type: String,
    required: [true, 'Filename is required'],
    trim: true
  },
  originalFilename: {
    type: String,
    trim: true
  },
  path: {
    type: String,
    required: [true, 'Path is required'],
    trim: true
  },
  url: {
    type: String,
    required: [true, 'URL is required'],
    trim: true
  },
  
  // Image type
  type: {
    type: String,
    enum: ['product', 'blog', 'category', 'social', 'other'],
    required: [true, 'Image type is required']
  },
  
  // Image metadata
  metadata: {
    width: {
      type: Number,
      required: [true, 'Width is required']
    },
    height: {
      type: Number,
      required: [true, 'Height is required']
    },
    format: {
      type: String,
      required: [true, 'Format is required'],
      trim: true
    },
    size: {
      type: Number, // Size in bytes
      required: [true, 'Size is required']
    },
    aspectRatio: {
      type: Number
    }
  },
  
  // Optimization data
  optimization: {
    isOptimized: {
      type: Boolean,
      default: false
    },
    originalSize: {
      type: Number // Size in bytes before optimization
    },
    compressionRate: {
      type: Number // Percentage of size reduction
    },
    optimizedAt: {
      type: Date
    }
  },
  
  // Source information
  source: {
    type: {
      type: String,
      enum: ['stock', 'ai_generated', 'uploaded', 'other'],
      required: [true, 'Source type is required']
    },
    provider: {
      type: String,
      trim: true
    },
    providerUrl: {
      type: String,
      trim: true
    },
    license: {
      type: String,
      trim: true
    },
    prompt: {
      type: String, // For AI-generated images
      trim: true
    },
    searchQuery: {
      type: String, // For stock images
      trim: true
    }
  },
  
  // SEO data
  seo: {
    altText: {
      type: String,
      trim: true
    },
    title: {
      type: String,
      trim: true
    },
    caption: {
      type: String,
      trim: true
    },
    keywords: [{
      type: String,
      trim: true
    }]
  },
  
  // Relationships
  relatedTo: {
    entityType: {
      type: String,
      enum: ['product', 'category', 'blog', 'other'],
      trim: true
    },
    entityId: {
      type: mongoose.Schema.Types.ObjectId,
      refPath: 'relatedTo.entityType'
    }
  },
  
  // Usage tracking
  usage: {
    usageCount: {
      type: Number,
      default: 0
    },
    lastUsedAt: {
      type: Date
    },
    locations: [{
      page: {
        type: String,
        trim: true
      },
      context: {
        type: String,
        trim: true
      },
      addedAt: {
        type: Date,
        default: Date.now
      }
    }]
  },
  
  // Status
  status: {
    type: String,
    enum: ['active', 'inactive', 'pending', 'deleted'],
    default: 'active'
  },
  
  // Automation fields
  automation: {
    isAutoGenerated: {
      type: Boolean,
      default: false
    },
    generationDate: {
      type: Date
    },
    generationParams: {
      type: Object
    }
  }
}, {
  timestamps: true
});

// Calculate aspect ratio before saving
ImageSchema.pre('save', function(next) {
  if (this.metadata.width && this.metadata.height) {
    this.metadata.aspectRatio = this.metadata.width / this.metadata.height;
  }
  next();
});

// Calculate compression rate before saving
ImageSchema.pre('save', function(next) {
  if (this.optimization.isOptimized && this.optimization.originalSize && this.metadata.size) {
    this.optimization.compressionRate = ((this.optimization.originalSize - this.metadata.size) / this.optimization.originalSize) * 100;
  }
  next();
});

module.exports = mongoose.model('Image', ImageSchema);
